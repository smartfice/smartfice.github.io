{"meta":{"title":"Monkey'blog","subtitle":"welcome to monkey","description":"Python Django Scrapy jQuery","author":"smartfice","url":"http://smartfice.com"},"pages":[{"title":"about","date":"2017-09-30T06:51:06.000Z","updated":"2017-09-30T06:51:06.629Z","comments":true,"path":"about/index.html","permalink":"http://smartfice.com/about/index.html","excerpt":"","text":""},{"title":"images","date":"2017-10-05T13:58:38.000Z","updated":"2017-10-05T13:58:38.059Z","comments":true,"path":"images/index.html","permalink":"http://smartfice.com/images/index.html","excerpt":"","text":""},{"title":"分类","date":"2017-10-08T08:55:36.000Z","updated":"2017-10-08T08:56:34.887Z","comments":true,"path":"categories/index.html","permalink":"http://smartfice.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-10-08T08:57:16.000Z","updated":"2017-10-08T08:57:47.425Z","comments":true,"path":"tags/index.html","permalink":"http://smartfice.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"django mysql数据库错误相关问题","slug":"mysql","date":"2017-08-09T14:18:15.000Z","updated":"2017-10-15T08:02:26.748Z","comments":true,"path":"mysql/","link":"","permalink":"http://smartfice.com/mysql/","excerpt":"","text":"1、当我把 DEBUG = True设为False的时候运行 Python manage.py runserver 的时候报错 ： CommandError: You must set settings.ALLOWED_HOSTS if DEBUG is False.解决方案：ALLOWED_HOSTS = [‘127.0.0.1’, ‘localhost’] 2、报错信息： ModelForm Creating a ModelForm without either the ‘fields’ attribute or the ‘exclude’ attributeis prohibited; form AuthorForm needs updating. 解决方案：class AuthorForm(ModelForm):class Meta:model = Authorfields = “all” 3、报错信息： CSRF token missing or incorrect解决方案：第一种方法： 第一步、 在 templete 中, 为每个 POST form 增加一个 {csrf_token 第二步、在 view 中, 使用 django.template.RequestContext 而不是 Context.render_to_response, 默认使用 Context. 需要改成 RequestContext.return render_to_response(‘systemofdingh/modify.html’, {‘form’: orderModelForm(instance=orderModify)},context_instance=RequestContext(request))第二中方法： settings.py 中 MIDDLEWARE_CLASSES 中 注释掉’django.middleware.csrf.CsrfViewMiddleware’ 在你的views.py 的方法上加上 @csrf_exempt 装饰 (需要 from django.views.decorators.csrf import csrf_exempt) You are trying to add a non-nullable field ‘orderID’ to ordermodel without a default; we can&apos;t do that (the database needs something to populate existing rows). Please select a fix: Provide a one-off default now (will be set on all existing rows) Quit, and let me add a default in models.py 解决方案: 删除migrate文件，然后重新来Django :queryset的长度查询： len(queryset)model对象转换成dict : model_to_dict问题：字段修改属性发生错误1&gt;12345&gt;python manage.py makemigrationsYou are trying to add a non-nullable field 'price_monthly' to product without a default; we can't do that (the database needs something to populate existing rows).Please select a fix: 1) Provide a one-off default now (will be set on all existing rows) 2) Quit, and let me add a default in models.pySelect an option: {这个可能是之前已创建了表中的一条记录，之后模型中增加了一个非空的字段，但是原来已经存在的记录没有这个值}2&gt;123&gt;python manage.py migrate... ...raise errorclass(errno, errorvalue)django.db.utils.ProgrammingError: (1146, \"Table 'lab_data.bigdata_postgraduate_research_directions' doesn't exist\") {这个是因为在字段中添加了blank=True或者 null=True引起的}3&gt; 1234567&gt;python manage.py makemigrationsYou are trying to change the nullable field 'job_title' on professor to non-nullable without a default; we can't do that (the database needs something to populate existing rows).Please select a fix: 1) Provide a one-off default now (will be set on all existing rows) 2) Ignore for now, and let me handle existing rows with NULL myself (e.g. adding a RunPython or RunSQL operation in the new migration file before the AlterField operation) 3) Quit, and let me add a default in models.pySelect an option: {这个是将模型中的null=True删除了之后产生的错误}1&gt;原因解释： 1234561. The migrations system is designed so that a single migration can be applied to more than one database. For example, you could have a development version, a staging version, and one or more production versions. That&apos;s whymaking the migration is a distinct step from applying the migration, and whymakemgirations can&apos;t just look at the currently active database to see that it doesn&apos;t have any rows. What if you then try to apply the migration to a database that does?The solution in your case is simple: since there are no rows, option 1 (setting a default on all existing rows) won&apos;t do anything at all. So choose option 1, and any value you like.[Django 1.7.1 requires a Default value for field - but no entry is in database. Why?]2. Django adds a default &quot;id&quot; field to every model, you don&apos;t need an extra &quot;twitbot_id&quot; in your model. If a surrogate primary key is all you need, forget about &quot;twitbot_id&quot; because it will be a duplicate of the auto-generated &quot;id&quot;. Seehttps://docs.djangoproject.com/en/dev/topics/db/models/#automatic-primary-key-fieldsIf you add this and you already have TwitterBot objects in your database you must provide a default value to populate this column for existing rows in the database.[Can&apos;t seem to lose this error: “You are trying to add a non-nullable field”] 如果你跟我一样是因为之前建好表a后，又创建一个表b作为a的父类，a中只有pass，那么因为表a已经创建，其中有数据，当a迁移时就会出现新表不能为null且没有指定默认值时就会出现这种错误。 解决方案：1&gt;在基类b中添加允许为空或者添加默认值，并设置b不建表（meta中的abstract = true）12345678910class Base(models.Model): ''' 基类 ''' title = models.CharField(max_length=150, null=True) content = models.TextField(null=True) time_stamp = models.DateTimeField(auto_now_add=True, default=timezone.now()) link = models.URLField(blank=True, verbose_name='url_link') class Meta: abstract = True Note:DataTimeField好像与其它的不一样，不好改！1&gt;2&gt;3&gt;删除所有migrate文件(不用移除整个文件夹)，然后重来 问题：manytomanyfeild没有默认值django admin gives warning “Field ‘X’ doesn’t have a default value” 问题：添加元属性发生错误12raise InternalError(errno, errorvalue)django.db.utils.InternalError: (1017, \"Can't find file: '.\\\\lab_data\\\\people_patent_prizes.frm' (errno: 2 -No such file or directory)\") {模型类中增加class Meta:db_table=’People’使数据库中对应的表名修改成了People，原来的表间联系可能破坏了}解决方案：删除所有migrate文件(不用移除整个文件夹)，然后重来 问题：表中字段不存在“Unknown column ‘name’ in ‘field list’” django中创建了表professor继承了表people的字段，并且在后台可以看到，但实际在数据库中不存在（数据库中查询可看到） 出现问题原因： model中编辑的字段没有在数据库对应的表里创建（原因可能是字段是继承自父类，出现的什么问题？） 数据库中查看表中的字段： migration文件出了什么问题？导致没有同步到数据库（表都没创建）解决方案1：在数据库中手动添加没有创建的字段alter table bigdata_professor add column name varchar(6); 再次查看表中字段： 再次运行django服务器，后台添加name字段时就不会出错了。 解决方案2：先删除整个migrations文件夹，再Python manage.py makemigrations,再python manage.py migrate 这样表就可以重新建立成功了！（可以查询到django中新建的表bigdata_professor….） Note: 成功后最好把之前删除的文件夹migrations重新建一个（app中的） 只删除migration文件可能不会出现这个问题：No migrations to apply. Your models have changes that are not yet reflected in a migration, and so won’t be applied. Run ‘manage.py makemigrations’ to make new migrations, and then re-run ‘manage.py migrate’ to apply them. 我了个去，都不知道为啥migration文件会出问题，删除后再操作就没事了，可能是（在makemigrations）之前先进行了migrate操作？[Django Models (1054, “Unknown column in ‘field list’”)] 问题：表不存在或者No migrations to apply “Table ‘lab_data.bigdata_resdir’ doesn’t exist” 模型中建立新表后，makemigrations成功，但是migrate出现错误: python manage.py migrateOperations to …:Apply all migrations: …No migrations to apply.(即使实际上明明makemigrations成功，并且有许多migrations可以应用) Your models have changes that are not yet reflected in a migration, and so won’t be applied. Run ‘manage.py makemigrations’ to make new migrations, and then re-run ‘manage.py migrate’ to apply them. 按照提示重新makemigration后migration文件就不会创建新表了，在数据库中表也的确没有新建。原因： Sounds like your initial migration was faked because the table already existed (probably with an outdated schema): “This will make a new initial migration for your app. Now, when you run migrate,Django will detect that you have an initial migration and that the tables it wants to create already exist, and will mark the migration as already applied.”Otherwise you would get an no-such-table error.[No migrations to apply, even though there are migrations to apply] 也可能是之前按照某个说明执行了一次python manage.py migrate –fake导致的。–fake 的含义是不执行该迁移脚本但是标记该脚本已经被执行过。导致之后无法正常进行迁移。[Django 1.7 中 migrate 无法执行而且表不存在的解决方案]解决方案：方法1. In MySQL Database delete row ‘app_name’ from the table ‘django_migrations’.打开mysql command line client, 进入创建好的数据库use databasename; 查看表select * from django_migration; 发现将要执行的迁移脚本的 id 已经添加在表中了，将其删除即可，即删除最新一次app_name对就的id行。 Delete all migration files in migrations folder. Try again python manage.py makemigrations and python manage.py migrate command.[Django 1.7 - “No migrations to apply” when run migrate after makemigrations]方法2：移除整个migrations文件夹，重新makemigrations和migrate。之后就会自动创建了： 方法3：实在不行，只能drop database，再重新建立了。 问题：外键修改成多对多错误ValueError: Cannot alter field bigdata.Postgraduate.publisher into bigdata.Postgraduate.publisher - they are not compatible types (you cannot alter to or from M2M fields, or add or remove through= on M2M fields) {这个错误是由将模型Postgraduate中的publisher字段从ForeignKey修改成ManyToManyField引起的}解决方案：删除所有migrations文件，重新makemigrations和migrate[foreignkey error: Django migration error :you cannot alter to or from M2M fields, or add or remove through= on M2M fields] 数据库注册到site管理错误TypeError: init() missing 2 required positional arguments : ‘model’ and ‘admin_site’ class DirectionsInline(inlineBase, admin.ModelAdmin): model = Directions inlines = [ImagesInline, ]admin.site.register(Directions, DirectionsInline) 解决：原因可能是继承admin.ModelAdmin的类中不能有model = * 数据库权限错误django.db.utils.operationalerror:&lt;1045,”access denied for user root@localhost using password yes&gt;解决方案1：django setting.py文件中设置的database用户名或者密码错了，修改一下就可以了或者是django运行项目时用的不是settings.py文件，这个在os.environ.setdefault(“DJANGO_SETTINGS_MODULE”, “labsite.settings”)中设置 其它方案：Access denied for user ‘root’@’localhost’ (using password: YES) mysql Access denied for user root@localhost错误解决方法总结(转)ERROR 1045 (28000): Access denied for user ‘root’@’localhost’ (using password: NO)MySQL Forums ::Install &amp; Repo ::ERROR 1045 (28000): Access denied for user ‘root’@’localhost’ (using password: NO)django.db.utils.operationalerror:&lt;2003, “can’t connect to mysql server on ‘127.0.0.1’(winerror 10061] No connection could be made because the target machine actively refused it)”)settings.py中设置的host和port如下‘HOST’: ‘127.0.0.1’,’PORT’: ‘3306’ 如改动port为其它，可能导致该问题其它问题：1.Error: Tablespace for table xxx exists. Please DISCARD the tablespace before IMPORT django.db.utils.ProgrammingError: (1146, “Table ‘lab_data.django_migrations’ doesn’t exist”)3.django.db.utils.InternalError: (1050, “Table ‘l ab_data.django_migrations‘already exists”) 1&gt;两个模型的数据库表名设置成一样的了class Meta: db_table = ‘WorkExp1’2&gt;python manage.py migrate –fakequestion:django.db.utils.InternalError: (1050, “Table ‘s_user_address’ already exists”) answer:./manage.py migrate myapp –fake 指定app 跳转//(py3_django) python@ubuntu:~/project/dailyfresh$ python manage.py migrate –fake –fakeOperations to perform: Synchronize unmigrated apps: staticfiles, messages, haystack, tinymce Apply all migrations: admin, df_cart, df_goods, djcelery, sessions, userinfo, auth, contenttypesSynchronizing apps without migrations: Creating tables… Running deferred SQL… Installing custom SQL…Running migrations: Rendering model states… DONE Applying userinfo.0001_initial… FAKED Applying df_goods.0001_initial… FAKED Applying df_cart.0001_initial… FAKED Applying djcelery.0001_initial… FAKED Applying djcelery.0002_auto_20170825_1331… FAKED Applying djcelery.0003_auto_20170827_0832… FAKED Applying djcelery.0004_auto_20170827_1256… FAKED Applying djcelery.0005_auto_20170828_0819… FAKED Applying djcelery.0006_auto_20170828_0826… FAKED Applying djcelery.0007_auto_20170828_1725… FAKED Applying djcelery.0008_auto_20170831_0830… FAKED Applying djcelery.0009_auto_20170831_1510… FAKED Applying djcelery.0010_auto_20170831_1514… FAKED Applying djcelery.0011_auto_20170831_1526… FAKED Applying djcelery.0012_auto_20170831_1532… FAKED Applying djcelery.0013_auto_20170831_1539… FAKED Applying djcelery.0014_auto_20170831_1552… FAKED Applying djcelery.0015_auto_20170831_1608… FAKED(py3_django) python@ubuntu:~/project/dailyfresh$ python manage.py migrate Operations to perform: Synchronize unmigrated apps: tinymce, haystack, messages, staticfiles Apply all migrations: djcelery, auth, userinfo, admin, contenttypes, df_cart, sessions, df_goodsSynchronizing apps without migrations: Creating tables… Running deferred SQL… Installing custom SQL…Running migrations: No migrations to apply. Your models have changes that are not yet reflected in a migration, and so won’t be applied. Run ‘manage.py makemigrations’ to make new migrations, and then re-run ‘manage.py migrate’ to apply them. (py3_django) python@ubuntu:~/project/dailyfresh$ python manage.py migrateOperations to perform: Synchronize unmigrated apps: messages, staticfiles, tinymce, haystack Apply all migrations: djcelery, df_goods, admin, df_cart, contenttypes, sessions, userinfo, authSynchronizing apps without migrations: Creating tables… Running deferred SQL… Installing custom SQL…Running migrations: Rendering model states… DONE Applying df_cart.0001_initial… OK(py3_django) python@ubuntu:~/project/dailyfresh$","categories":[{"name":"django","slug":"django","permalink":"http://smartfice.com/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://smartfice.com/tags/django/"},{"name":"mysql","slug":"mysql","permalink":"http://smartfice.com/tags/mysql/"}]},{"title":"Flask路由装饰器","slug":"python2","date":"2017-07-22T13:53:36.000Z","updated":"2017-10-15T14:02:37.999Z","comments":true,"path":"python2/","link":"","permalink":"http://smartfice.com/python2/","excerpt":"","text":"flask有个Werkzeug的python函数库或者werkzeug工具箱。 werkzeug库的routing模块整体上负责flask路由的分发。 routing模块内有三个类Rule类（构造不同的URL模式的对象）、Map类（存储所有的URL规则（或者映射））、MapAdapter(负责具体的URL匹配的工作)共同实现的。 每一个装饰器路由，比如根路由根视图函数之间的匹配是MapAdapter(url跟视图函数对应的真正匹配的)实现的。 Werkzeug 是一个 WSGI 工具包。WSGI 是一个 Web 应用和服务器通信的协议，Web 应用 可以通过 WSGI 一起工作。一个基本的 “Hello World” WSGI 应用看起来是这样的: 123def application(environ, start_response): start_response('200 OK', [('Content-Type', 'text/plain')]) return ['Hello World!'] 用过 WSGI 应用可以和环境通信，他有一个可调用的 start_response 。环境包含了 所有进来的信息。 start_response 用来表明已经收到一个响应。通过 Werkzeug * 你可以不必直接处理请求或者响应这些底层的东西，它已经为你封装好了这些。 请求数据需要环境对象，Werkzeug 允许你以一个轻松的方式访问数据。响应对象是一个 WSGI 应用，提供了更好的方法来创建响应。 下面教你怎么用响应对象来写一个应用: 12345from werkzeug.wrappers import Responsedef application(environ, start_response): response = Response('Hello World!', mimetype='text/plain') return response(environ, start_response) 这里有一个在 URL 中查询字符串的扩展版本(重点是 URL 中的 name 将会替代 World): 12345678Request ,Responsefrom werkzeug.wrappers import Request, Responsedef applicatio n(environ, start_response): request = Request(environ) text = 'Hello %s!' % request.args.get('name', 'World') response = Response(text, mimetype='text/plain') return response(environ, start_response)","categories":[{"name":"flask","slug":"flask","permalink":"http://smartfice.com/categories/flask/"}],"tags":[{"name":"Flask","slug":"Flask","permalink":"http://smartfice.com/tags/Flask/"}]},{"title":"Django middleware","slug":"middleware","date":"2017-06-13T12:11:12.000Z","updated":"2017-10-15T08:07:16.432Z","comments":true,"path":"middleware/","link":"","permalink":"http://smartfice.com/middleware/","excerpt":"","text":"Django中间件是一个轻量级、底层的插件系统，可以介入Django的请求和响应处理过程，修改Django的输入或输出。中间件为设计开发者提供了一种无侵入式的开发方式。在middleware.py文件中定义中间件类： init(self) :服务器响应第一个请求的时候调用。 process_request(self, request)(每个请求上调用,返回None或者HttpResponse对象)：是产生request对象,进行url匹配之前调用 process_view(self, request, view_func, view_args, *view_kwargs)（每个请求上调用,返回None或者HttpResponse对象 ）:是url匹配之后,调用视图函数之前. process_response(self, request, response)（每个请求上调用,返回HttpResponse对象 ）:视图函数调用之后，内容返回给浏览器之前。 process_exception(self, request, exception)（每个请求上调用,返回HttpResponse对象 ）:视图函数出现异常，会调用这个函数如果多个中间件类包含process_exception函数的时候，调用的顺序跟注册的顺序是相反的 注册中间件类：settings.py MIDDLEWARE_CLASSES = [ ]比如我们要做一个 拦截器，发生有恶意访问网站的人，就拦截他！Django中间件实现拦截器 JavaWeb Struts2的拦截器我们都能很熟悉，在请求交给Action处理之前，先在拦截器中处理，处理完之后再交给Action。在Django中如何实现相同的效果? 在process_request方法中，返回值为HttpResponse类型的对象的时候不交给普通的控制器处理，直接返回给浏览器，返回值为None的时候，请求处理完之后交给普通的控制器处理。 使用request对象的META属性：request.META[‘REMOTE_ADDR’] 获取访问者的ip 假如我们通过一种技术，比如统计一分钟访问页面数，太多就把他的 IP 加入到黑名单 BLOCKED_IPS（这部分没有提供代码，主要讲中间件部分）项目 文件名 zscf 1234class BlockedIpMiddleware(object): def process_request(self, request): if request.META['REMOTE_ADDR'] in getattr(settings, \"BLOCKED_IPS\", []): return http.HttpResponseForbidden('&lt;h1&gt;Forbidden&lt;/h1&gt;') 这里的代码的功能就是 获取当前访问者的 IP (request.META[‘REMOTE_ADDR’])，如果这个 IP 在黑名单中就拦截，如果不在就返回 None (函数中没有返回值其实就是默认为 None)，把这个中间件的 Python 路径写到settings.py中 1234MIDDLEWARE_CLASSES = ( 'zscf.middleware.BlockedIpMiddleware', ...其它的中间件) Django 会从 MIDDLEWARE_CLASSES 中按照从上到下的顺序一个个执行中间件中的 process_request 函数，而其中 process_response 函数则是最前面的最后执行。 再比如，我们在网站放到服务器上正式运行后，DEBUG改为了 False，这样更安全，但是有时候发生错误不能显示错误详情页面，有没有办法处理好这两个事情呢？ 普通访问者看到的是友好的报错信息 管理员看到的是错误详情，以便于修复 BUG 当然可以有，利用中间件就可以做到！代码如下：12345678import sysfrom django.views.debug import technical_500_responsefrom django.conf import settings class UserBasedExceptionMiddleware(object): def process_exception(self, request, exception): if request.user.is_superuser or request.META.get('REMOTE_ADDR') in settings.INTERNAL_IPS: return technical_500_response(request, *sys.exc_info()) 把这个中间件像上面一样，加到你的 settings.py 中的 MIDDLEWARE_CLASSES 中，可以放到最后，这样可以看到其它中间件的 process_request的错误。","categories":[{"name":"django","slug":"django","permalink":"http://smartfice.com/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://smartfice.com/tags/django/"},{"name":"python","slug":"python","permalink":"http://smartfice.com/tags/python/"}]},{"title":"Django权限机制","slug":"django1","date":"2017-05-26T13:53:36.000Z","updated":"2017-10-15T13:44:03.134Z","comments":true,"path":"django1/","link":"","permalink":"http://smartfice.com/django1/","excerpt":"","text":"Django权限机制概述权限机制能够约束用户行为，控制页面的显示内容，也能使API更加安全和灵活；用好权限机制，能让系统更加强大和健壮。因此，基于Django的开发，理清Django权限机制是非常必要的。 Django的权限控制Django用user, group和permission完成了权限机制，这个权限机制是将属于model的某个permission赋予user或group，可以理解为全局的权限，即如果用户A对数据模型（model）B有可写权限，那么A能修改model B的所有实例（objects）。group的权限也是如此，如果为group C 赋予model B的可写权限，则隶属于group C 的所有用户，都可以修改model B的所有实例。 这种权限机制只能解决一些简单的应用需求，而大部分应用场景下，需要更细分的权限机制。以博客系统为例，博客系统的用户可分为『管理员』、『编辑』、『作者』和『读者』四个用户组；博客系统管理员和编辑具有查看、修改和删除所有的文章的权限，作者只能修改和删除自己写的文章，而读者则只有阅读权限。管理员、编辑和读者的权限，我们可以用全局权限做控制，而对于作者，全局权限无法满足需求，仅通过全局权限，要么允许作者编辑不属于自己的文章，要么让作者连自己的文章都无法修改。 上述的应用场景，Django自带的权限机制无法满足需求，需要引入另一种更细的权限机制：对象权限（object permission）。 Object Permission是一种对象颗粒度上的权限机制，它允许为每个具体对象授权。仍沿用最开始的例子，如果model B有三个实例 B1，B2 和B3，如果我们把B1的可写权限赋予用户A，则A可以修改B1对象，而对B2，B3无法修改。对group也一样，如果将B2的可写权限赋予group C，则隶属于group C的所有用户均可以修改B2，但无法修改B1和B3。结合Django自带权限机制和object permission，博客系统中作者的权限控制迎刃而解：系统全局上不允许作者编辑文章，而对于属于作者的具体文章，赋予编辑权限即可。Django其实包含了object permission的框架，但没有具体实现，object permission的实现需要借助第三方app django-guardian，我们在开发中用调用django guradian封装好的方法即可。 Django的权限项 Django用permission对象存储权限项，每个model默认都有三个permission，即add model, change model和delete model。例如，定义一个名为『Car』model，定义好Car之后，会自动创建相应的三个permission：add_car, change_car和delete_car。Django还允许自定义permission，例如，我们可以为Car创建新的权限项：drive_car, clean_car, fix_car等等 需要注意的是，permission总是与model对应的，如果一个object不是model的实例，我们无法为它创建/分配权限。 Django 自带权限机制的应用Permission 如上文所述，Django定义每个model后，默认都会添加该model的add, change和delete三个permission，自定义的permission可以在我们定义model时手动添加： 12345678class Task(models.Model): ... class Meta: permissions = ( (\"view_task\", \"Can see available tasks\"), (\"change_task_status\", \"Can change the status of tasks\"), (\"close_task\", \"Can remove a task by setting its status as closed\"), ) 每个permission都是django.contrib.auth.Permission类型的实例，该类型包含三个字段name, codename 和 content_type，其中 content_type反应了permission属于哪个model，codename如上面的view_task，代码逻辑中检查权限时要用， name是permission的描述，将permission打印到屏幕或页面时默认显示的就是name 在model中创建自定义权限，从系统开发的角度，可理解为创建系统的内置权限，如果需求中涉及到用户使用系统时创建自定义权限，则要通过下面方法：12345678from myapp.models import BlogPostfrom django.contrib.auth.models import Permissionfrom django.contrib.contenttypes.models import ContentTypecontent_type = ContentType.objects.get_for_model(BlogPost)permission = Permission.objects.create(codename='can_publish', name='Can Publish Posts', content_type=content_type) User Permission管理 User对象的user_permission字段管理用户的权限： 1234myuser.user_permissions = [permission_list]myuser.user_permissions.add(permission, permission, ...) #增加权限myuser.user_permissions.remove(permission, permission, ...) #删除权限myuser.user_permissions.clear() #清空权限 注：上面的permission为django.contrib.auth.Permission类型的实例检查用户权限用has_perm()方法：myuser.has_perm(‘myapp.fix_car’) has_perm()方法的参数，即permission的codename，但传递参数时需要加上model 所属app的前缀，格式为.。无论permission赋予user还是group，has_perm()方法均适用附注：12user.get_all_permissions()方法列出用户的所有权限，返回值是permission name的listuser.get_group_permissions()方法列出用户所属group的权限，返回值是permission name的list Group Permission管理grouppermission管理逻辑与user permission管理一致，group中使用permissions字段做权限管理：123456group.permissions = [permission_list]group.permissions.add(permission, permission, ...)group.permissions.remove(permission, permission, ...)group.permissions.clear()权限检查：依然使用user.has_perm()方法。 permission_required 装饰器 权限能约束用户行为，当业务逻辑中涉及到权限检查时，decorator能够分离权限验证和核心的业务逻辑，使代码更简洁，逻辑更清晰。permission的decorator为permission_required：1234from django.contrib.auth.decorators import permission_required@permission_required('car.drive_car')def my_view(request): ... Template中的权限检查 Template中使用全局变量perms存储当前用户的所有权限，权限检查可以参考下面例子：12345678910&#123;% if perms.main.add_page %&#125; &lt;li class=\"dropdown\"&gt; &lt;a href=\"#\" class=\"dropdown-toggle\" data-toggle=\"dropdown\" role=\"button\" aria-expanded=\"false\"&gt;Pages &lt;span class=\"caret\"&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class=\"dropdown-menu\" role=\"menu\"&gt; &lt;li&gt;&lt;a href=\"&#123;% url 'main:admin_pages' %&#125;\"&gt;All Pages&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"&#123;% url 'main:admin_page' %&#125;\"&gt;New Page&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"&#123;% url 'main:admin_pages' %&#125;?draft=true\"&gt;Drafts&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt;&#123;% endif %&#125; 基于Django-guardian的object permission的应用 Django-guardian基于django的原生逻辑扩展了django的权限机制，应用django-guardian后，可以使用django-guardian提供的方法以及django的原生方法检查全局权限，django-guardian提供的object permission机制使django的权限机制更加完善。 django-guardian详细的使用文档请参考官方文档，其object permission常用方法如下：123from guardian.shortcuts import assign_perm, get_permsfrom guardian.core import ObjectPermissionCheckerfrom guardian.decorators import permission_required 添加object permission添加object permission使用assign_perm()方法，如为用户添加对mycar对象的drive_car权限：123assign_perm(&apos;myapp.drive_car&apos;, request.user, mycar)assign_perm()方法也可用于groupassign_perm(&apos;myapp.drive_car&apos;, mygroup, mycar) 权限检查3.2.1 Global permissionget_perms()方法用于检查用户的“全局权限”（global permission），与user.has_perm()异曲同工，如：1234if not 'main.change_post' in get_perms(request.user, post): raise HttpResponse('Forbidden')if not request.user.has_perm('main.change_post') return HttpResponse('Forbidden') 例子中虽然把post object作为参数传给get_perms()方法，但它只检查user的全局权限中是否有main.change_post权限，很多情况下可用原生的user.has_perm取代，但user和group均可作为get_perms()的传入参数，某些情况下可以使代码更简洁。 Object permissionDjango-guardian中使用* ObjectPermissionChecker检查用户的object permission，示例如下：12checker = ObjectPermissionChecker(request.user)print checker.has_perm('main.change_post', post) permission_required装饰器 guardian.decorators.permission_required是django-guardian权限检查的decorator，既可以检查全局权限，又可以检查对象权限（object permission），其中，accept_global_perms参数指出是否检查user的global permission，如： 12345678910111213141516171819from guardian.decorators import permission_requiredclass DeletePost(View): @method_decorator(permission_required('main.delete_post', (models.Post, 'id', 'pk'), accept_global_perms=True)) def get(self, request, pk): try: pk = int(pk) cur_post = models.Post.objects.get(pk=pk) is_draft = cur_post.is_draft url = reverse('main:admin_posts') if is_draft: url = '&#123;0&#125;?draft=true'.format(url) cur_post.delete() except models.Post.DoesNotExist: raise Http404 return redirect(url) 注：decorator中的(models.Post, ‘id’, ‘pk’)部分，用于指定object实例，如果忽略这个参数，则不论accept_global_perms值为True还是False，均仅仅检查全局权限。 结论Django原生提供了一种简单的全局权限（global permission）控制机制，但很多应用场景下，对象权限（object permission）更加有用；django-guardian是目前比较活跃的一个django extension，提供了一种有效的object permission控制机制，与django原生机制一脉相承。","categories":[{"name":"django","slug":"django","permalink":"http://smartfice.com/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://smartfice.com/tags/django/"}]},{"title":"python类的魔法方法、属性！！！","slug":"pythonmagic","date":"2017-03-28T13:53:36.000Z","updated":"2017-10-11T07:21:21.762Z","comments":true,"path":"pythonmagic/","link":"","permalink":"http://smartfice.com/pythonmagic/","excerpt":"","text":"为了确保类是新型类，应该把 metaclass=type 入到你的模块的最开始。1234class NewType(Object): mor_code_hereclass OldType: mor_code_here 在这个两个类中NewType是新类，OldType是属于旧类，如果前面加上 metaclass=type ，那么两个类都属于新类。构造方法构造方法与其的方法不一样，当一个对象被创建会立即调用构造方法。创建一个python的构造方法很简答，只要把init方法，从简单的init方法，转换成魔法版本的init方法就可以了。1234567class FooBar: def __init__(self): self.somevar = 42 &gt;&gt;&gt; f =FooBar()&gt;&gt;&gt; f.somevar42 重写一个一般方法 每一个类都可能拥有一个或多个超类（父类），它们从超类那里继承行为方法。 12345678910class A: def hello(self): print 'hello . I am A.'class B(A): pass&gt;&gt;&gt; a = A()&gt;&gt;&gt; b = B()&gt;&gt;&gt; a.hello()hello . I am A. 因为B类没有hello方法，B类继承了A类，所以会调用A 类的hello方法。 在子类中增加功能功能的最基本的方式就是增加方法。但是也可以重写一些超类的方法来自定义继承的行为。如下：12345678910class A: def hello(self): print 'hello . I am A.'class B(A): def hello(self): print 'hello . I am B'&gt;&gt;&gt; b = B()&gt;&gt;&gt; b.hello()hello . I am B 特殊的和构造方法 重写是继承机制中的一个重要内容，对一于构造方法尤其重要。看下面的例子： 123456789101112131415class Bird: def __init__(self): self.hungry = True def eat(self): if self.hungry: print 'Aaaah...' self.hungry = False else: print 'No, thanks!'&gt;&gt;&gt; b = Bird()&gt;&gt;&gt; b.eat()Aaaah...&gt;&gt;&gt; b.eat()No, thanks! 这个类中定义了鸟有吃的能力， 当它吃过一次后再次就会不饿了，通过上面的执行结果可以清晰的看到。 那么用SongBird类来继承Bird 类，并且给它添加歌唱的方法： 12345678910111213141516171819202122232425262728class Bird: def __init__(self): self.hungry = True def eat(self): if self.hungry: print 'Aaaah...' self.hungry = False else: print 'No, thanks!' class SongBird(Bird): def __init__(self): self.sound = 'Squawk!' def sing(self): print self.sound&gt;&gt;&gt; s = SongBird()&gt;&gt;&gt; s.sing()Squawk!&gt;&gt;&gt; s.eat()Traceback (most recent call last): File \"&lt;pyshell#26&gt;\", line 1, in &lt;module&gt; s.eat() File \"C:/Python27/bird\", line 6, in eat if self.hungry:AttributeError: 'SongBird' object has no attribute 'hungry' 异常很清楚地说明了错误：SongBird没有hungry特性。原因是这样的：在SongBird中，构造方法被重写，但新的构造方法没有任何关于初始化hungry特性的代码。为了达到预期的效果，SongBird的构造方法必须调用其超类Bird的构造方法来确保进行基本的初始化。 两种方法实现：一 、调用未绑定的超类构造方法1234567891011121314151617181920212223242526class Bird: def __init__(self): self.hungry = True def eat(self): if self.hungry: print 'Aaaah...' self.hungry = False else: print 'No, thanks!' class SongBird(Bird): def __init__(self): Bird.__init__(self) self.sound = 'Squawk!' def sing(self): print self.sound&gt;&gt;&gt; s = SongBird()&gt;&gt;&gt; s.sing()Squawk!&gt;&gt;&gt; s.eat()Aaaah...&gt;&gt;&gt; s.eat()No, thanks! 在SongBird类中添加了一行代码Bird.init(self) 。 在调用一个实例的方法时，该方法的self参数会被自动绑定到实例上（这称为绑定方法）。但如果直接调用类的方法，那么就没有实例会被绑定。这样就可以自由地提供需要的self参数（这样的方法称为未绑定方法）。 通过将当前的实例作为self参数提供给未绑定方法，SongBird就能够使用其超类构造方法的所有实现，也就是说属性hungry能被设置。 二、使用super函数12345678910111213141516171819202122232425__metaclass__ = type #表明为新式类class Bird: def __init__(self): self.hungry = True def eat(self): if self.hungry: print 'Aaaah...' self.hungry = False else: print 'No, thanks!' class SongBird(Bird): def __init__(self): super(SongBird,self).__init__() self.sound = 'Squawk!' def sing(self): print self.sound&gt;&gt;&gt; s.sing()Squawk!&gt;&gt;&gt; s.eat()Aaaah...&gt;&gt;&gt; s.eat()No, thanks! super函数只能在新式类中使用。当前类和对象可以作为super函数的参数使用，调用函数返回的对象的任何方法都是调用超类的方法，而不是当前类的方法。那就可以不同在SongBird的构造方法中使用Bird,而直接使用super(SongBird,self)。 属性 访问器是一个简单的方法，它能够使用getHeight 、setHeight 之样的名字来得到或者重绑定一些特性。如果在访问给定的特性时必须要采取一些行动，那么像这样的封装状态变量就很重要。如下： 1234567891011121314151617class Rectangle: def __init__(self): self.width = 0 self.height = 0 def setSize(self,size): self.width , self.height = size def getSize(self): return self.width , self.height&gt;&gt;&gt; r = Rectangle()&gt;&gt;&gt; r.width = 10&gt;&gt;&gt; r.height = 5&gt;&gt;&gt; r.getSize()(10, 5)&gt;&gt;&gt; r.setSize((150,100))&gt;&gt;&gt; r.width150 在上面的例子中，getSize和setSize方法一个名为size的假想特性的访问器方法，size是由width 和height构成的元组。 property 函数 property函数的使用很简单，如果已经编写了一个像上节的Rectangle 那样的类，那么只要增加一行代码： 1234567891011121314151617181920__metaclass__ = typeclass Rectangle: def __int__(self): self.width = 0 self.height = 0 def setSize(self,size): self.width, self.height = size def getSize(self): return self.width ,self.height size = property(getSize ,setSize)&gt;&gt;&gt; r = Rectangle()&gt;&gt;&gt; r.width = 10&gt;&gt;&gt; r.height = 5&gt;&gt;&gt; r.size(10, 5)&gt;&gt;&gt; r.size = 150,100&gt;&gt;&gt; r.width150 在这个新版的Retangle 中，property 函数创建了一个属性，其中访问器函数被用作参数（先取值，然后是赋值），这个属性命为size 。这样一来就不再需要担心是怎么实现的了，可以用同样的方式处理width、height 和size。","categories":[{"name":"Python","slug":"Python","permalink":"http://smartfice.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://smartfice.com/tags/Python/"}]},{"title":"Python是如何进行内存管理的？","slug":"pythongc","date":"2016-10-13T15:11:12.000Z","updated":"2017-10-11T06:48:23.776Z","comments":true,"path":"pythongc/","link":"","permalink":"http://smartfice.com/pythongc/","excerpt":"","text":"一、对象的引用计数机制Python内部使用引用计数，来保持追踪内存中的对象，所有对象都有引用计数。 引用计数增加的情况： 一个对象分配一个新名称 将其放入一个容器中（如列表、元组或字典） 对象被创建，例如a=23 对象被引用，例如b=a 对象被作为参数，传入到一个函数中，例如func(a) 对象作为一个元素，存储在容器中，例如list1=[a,a] 引用计数减少的情况： 使用del语句对对象别名显示的销毁 引用超出作用域或被重新赋值 对象的别名被显式销毁，例如del a 对象的别名被赋予新的对象，例如a=24 一个对象离开它的作用域，例如f函数执行完毕时，func函数中的* 局部变量（全局变量不会） 对象所在的容器被销毁，或从容器中删除对象 import sys sys.getrefcount( )函数可以获得对象的当前引用计数多数情况下，引用计数比你猜测得要大得多。对于不可变数据（如数字和字符串），解释器会在程序的不同部分共享内存，以便节约内存。二、垃圾回收机制1，当一个对象的引用计数归零时，它将被垃圾收集机制处理掉。 python采用的是引用计数机制为主，分代收集机（解决循环引用）制为辅的策略。循环引用导致内存泄露:申请了某些内存，但是忘记了释放，那么这就造成了内存的浪费。 分代收集机制的原理： python中的零代(genneration zore) 垃圾检查10次(python会循环遍历零代列表上的每个对象，找出列表中每个互相引用的对象，根据规则减掉其引用计数) 一代链表（gennerator one）垃圾检查10次 (零代链表转移到一代) 循环遍历每个对象 二代链表（generation one） 一代链表转移到二代 python 分配内存的数目减去释放内存的数目，注意是内存分配，而不是引用计数增加。 2，当两个对象a和b相互引用时，del语句可以减少a和b的引用计数，并销毁用于引用底层对象的名称。 然而由于每个对象都包含一个对其他对象的应用，因此引用计数不会归零，对象也不会销毁。（循环引用导致内存泄露 | 从而导致内存泄露）。为解决这一问题，解释器会定期执行一个循环检测器，搜索不可访问对象的循环并删除它们。三、内存池机制 Python提供了对内存的垃圾收集机制，但是它将不用的内存放到内存池而不是返回给操作系统。 Pymalloc机制。为了加速Python的执行效率，Python引入了一个内存池机制，用于管理对小块内存的申请和释放。 Python中所有小于256个字节的对象都使用pymalloc实现的分配器，而大的对象则使用系统的malloc。 对于Python对象，如整数，浮点数和List，都有其独立的私有内存池，对象间不共享他们的内存池。也就是说如果你分配又释放了大量的整数，用于缓存这些整数的内存就不能再分配给浮点数。","categories":[{"name":"Python","slug":"Python","permalink":"http://smartfice.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://smartfice.com/tags/Python/"}]},{"title":"Redis事务和持久化","slug":"redis","date":"2016-09-13T15:16:13.000Z","updated":"2017-10-15T08:03:58.980Z","comments":true,"path":"redis/","link":"","permalink":"http://smartfice.com/redis/","excerpt":"","text":"本文将介绍Reids的事务，数据持久化等相关知识;Redis事务 用Multi(Start Transaction)、Exec(Commit)、Discard(Rollback)实现。 在事务提交前，不会执行任何指令，只会把它们存到一个队列里，不影响其他客户端的操作。在事务提交时，批量执行所有指令，并且带有以下两个重要的保证： 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。 事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。 1.1 事务用法 MULTI 命令用于开启一个事务，它总是返回OK。MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。 另一方面，通过调用DISCARD，客户端可以清空事务队列，并放弃执行事务。 一个事务从开始到执行会经历以下三个阶段： 开始事务; 命令入队; 执行事务。使用实例如下：123456789101112131415127.0.0.1:6379&gt; MULTI //开启事务OK127.0.0.1:6379&gt; SET minhow 'Redis MySQL' //设置minhow的值QUEUED127.0.0.1:6379&gt; GET minhow //获取minhow的值QUEUED127.0.0.1:6379&gt; SADD name 'minhow' // 添加name集合QUEUED127.0.0.1:6379&gt; SMEMBERS name // 列出集合name的所有元素QUEUED127.0.0.1:6379&gt; EXEC //提交1) OK2) \"Redis MySQL\"3) (integer) 14) 1) \"minhow\" EXEC 命令的回复是一个数组，数组中的每个元素都是执行事务中的命令所产生的回复。其中，回复元素的先后顺序和命令发送的先后顺序一致。 当客户端处于事务状态时，所有传入的命令都会返回一个内容为QUEUED 的状态回复（status reply），这些被入队的命令将在EXEC命令被调用时执行。 1.2 事务中的错误 对于事务的执行来说，如果redis开启了AOF持久化的话，那么一旦事务被成功执行，事务中的命令就会通过write命令一次性写到磁盘中去，如果在向磁盘中写的过程中恰好出现断电、硬件故障等问题，那么就可能出现只有部分命令进行了AOF持久化，这时AOF文件就会出现不完整的情况，这时，我们可以使用redis-check-aof工具来修复这一问题，这个工具会将AOF文件中不完整的信息移除，确保AOF文件完整可用。使用事务时可能会遇上以下两种错误： 事务在执行 EXEC 之前，入队的命令可能会出错。比如说，命令可能会产生语法错误（参数数量错误，参数名错误，等等），或者其他更严重的错误，比如内存不足（如果服务器使用 maxmemory 设置了最大内存限制的话）。 命令可能在 EXEC 调用之后失败。举个例子，事务中的命令可能处理了错误类型的键，比如将列表命令用在了字符串键上面，诸如此类。对于发生在EXEC执行之前的错误，客户端以前的做法是检查命令入队所得的返回值：如果命令入队时返回QUEUED，那么入队成功；否则，就是入队失败。如果有命令在入队时失败，那么大部分客户端都会停止并取消这个事务。不过，从Redis 2.6.5开始，服务器会对命令入队失败的情况进行记录，并在客户端调用EXEC命令时，拒绝执行并自动放弃这个事务。实例如下： 1234567891011121314151617181920127.0.0.1:6379&gt; MULTIOK127.0.0.1:6379&gt; minhow //明显的语法错误(error) ERR unknown command 'minhow'127.0.0.1:6379&gt; SET minhow mmQUEUED127.0.0.1:6379&gt; EXEC(error) EXECABORT Transaction discarded because of previous errors.``` * 拒绝执行，之前出现了错误.而对于发生在EXEC执行之后的错误，Redis则采取了完全不同的策略，即Redis不会理睬这些错误，而是继续向下执行事务中的其他命令。这是因为，对于应用层面的错误，并不是Redis自身需要考虑和处理的问题，所以一个事务中如果某一条命令执行失败，并不会影响接下来的其他命令的执行。实例如下：```sql127.0.0.1:6379&gt; MULTIOK127.0.0.1:6379&gt; SET minhow 'name'QUEUED127.0.0.1:6379&gt; SADD minhow 'name' //minhow不是集合，出错QUEUED127.0.0.1:6379&gt; EXEC //第一条OK，第二条error1) OK2) (error) WRONGTYPE Operation against a key holding the wrong kind of value 最重要的是记住这样一条， 即使事务中有某条/某些命令执行失败了， 事务队列中的其他命令仍然会继续执行 —— Redis 不会停止执行事务中的命令。 1.3 事务不支持回滚 如果你有使用关系式数据库的经验， 那么 “Redis 在事务失败时不进行回滚，而是继续执行余下的命令”这种做法可能会让你觉得有点奇怪。以下是这种做法的优点： Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。 因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。 有种观点认为 Redis 处理事务的做法会产生 bug ， 然而需要注意的是， 在通常情况下， 回滚并不能解决编程错误带来的问题。 举个例子， 如果你本来想通过 INCR 命令将键的值加上 1 ， 却不小心加上了 2 ， 又或者对错误类型的键执行了 INCR ， 回滚是没有办法处理这些情况的。 1.4 事务WATCH—乐观锁WATCH命令可以为Redis事务提供check-and-set（CAS）行为。被WATCH的键会被监视，并会发觉这些键是否被改动过了。 如果有至少一个被监视的键在EXEC执行之前被修改了，那么整个事务都会被取消， EXEC返回nil-reply来表示事务已经失败。实例如下：1234567891011121314127.0.0.1:6379&gt; SET minhow 109 //设置minhow的值OK127.0.0.1:6379&gt; WATCH minhow //监视minhowOK127.0.0.1:6379&gt; SET minhow 09 //修改minhow的值OK127.0.0.1:6379&gt; MULTIOK127.0.0.1:6379&gt; SET minhow 9QUEUED127.0.0.1:6379&gt; GET minhowQUEUED127.0.0.1:6379&gt; EXEC //执行失败(nil) WATCH使得EXEC命令需要有条件地执行： 事务只能在所有被监视键都没有被修改的前提下执行， 如果这个前提不能满足的话，事务就不会被执行。 2. Redis持久化 R* edis提供了两种持久化的方式，分别是RDB（Redis DataBase）和AOF（Append Only File）。 RDB，就是在不同的时间点，将Redis存储的数据生成快照并存储到磁盘等介质上； AOF，则是换了一个角度来实现持久化，那就是将redis执行过的所有写指令记录下来，在下次Redis重新启动时，只要把这些写指令从前到后再重复执行一遍，就可以实现数据恢复了，Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大。 其实RDB和AOF两种方式也可以同时使用，在这种情况下，如果Redis重启的话，则会优先采用AOF方式来进行数据恢复，这是因为AOF方式的数据恢复完整度更高。 如果你没有数据持久化的需求，也完全可以关闭RDB和AOF方式，这样的话，Redis将变成一个纯内存数据库，就像memcache一样。 2.1 Redis持久化- -RDBRDB方式，是将Redis某一时刻的数据持久化到磁盘中，是一种快照式的持久化方法。 优点： RDB是一个非常紧凑的文件,它保存了某个时间点得数据集,非常适用于数据集的备份,比如你可以在每个小时报保存一下过去24小时内的数据,同时每天保存过去30天的数据,这样即使出了问题你也可以根据需求恢复到不同版本的数据集。 RDB是一个紧凑的单一文件,很方便传送到另一个远端数据中心或者亚马逊的S3（可能加密），非常适用于灾难恢复。 RDB在保存RDB文件时父进程唯一需要做的就是fork出一个子进程,接下来的工作全部由子进程来做，父进程不需要再做其他IO操作，所以RDB持久化方式可以最大化redis的性能。 与AOF相比,在恢复大的数据集的时候，RDB方式会更快一些。 缺点： 如果你希望在redis意外停止工作（例如电源中断）的情况下丢失的数据最少的话，那么RDB不适合你.虽然你可以配置不同的save时间点(例如每隔5分钟并且对数据集有100个写的操作),是Redis要完整的保存整个数据集是一个比较繁重的工作,你通常会每隔5分钟或者更久做一次完整的保存,万一在Redis意外宕机,你可能会丢失几分钟的数据。 RDB 需要经常fork子进程来保存数据集到硬盘上,当数据集比较大的时候,fork的过程是非常耗时的,可能会导致Redis在一些毫秒级内不能响应客户端的请求.如果数据集巨大并且CPU性能不是很好的情况下,这种情况会持续1秒,AOF也需要fork,但是你可以调节重写日志文件的频率来提高数据集的耐久度。 2.2 Redis持久化- -AOF AOF，英文是Append Only File，即只允许追加不允许改写的文件；通过配置redis.conf中的appendonly yes就可以打开AOF功能。如果有写操作（如SET等），Redis就会被追加到AOF文件的末尾。 优点： 使用AOF 会让你的Redis更加耐久: 你可以使用不同的fsync策略：无fsync,每秒fsync,每次写的时候fsync.使用默认的每秒fsync策略,Redis的性能依然很好(fsync是由后台线程进行处理的,主线程会尽力处理客户端请求),一旦出现故障，你最多丢失1秒的数据. AOF文件是一个只进行追加的日志文件,所以不需要写入seek,即使由于某些原因(磁盘空间已满，写的过程中宕机等等)未执行完整的写入命令,你也也可使用redis-check-aof工具修复这些问题。 Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。 整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。 AOF 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 Redis 协议的格式保存， 因此 AOF 文件的内容非常容易被人读懂， 对文件进行分析（parse）也很轻松。 导出（export） AOF 文件也非常简单： 举个例子， 如果你不小心执行了 FLUSHALL 命令， 但只要 AOF 文件未被重写， 那么只要停止服务器， 移除 AOF 文件末尾的 FLUSHALL 命令， 并重启 Redis ， 就可以将数据集恢复到 FLUSHALL 执行之前的状态。缺点： 对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。 根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB 。 在一般情况下， 每秒 fsync 的性能依然非常高， 而关闭 fsync 可以让 AOF 的速度和 RDB 一样快， 即使在高负荷之下也是如此。 不过在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间（latency）。 2.3 Redis持久化- -如何选择RDB和AOF 一般来说， 你应该同时使用两种持久化功能。 如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久化。 有很多用户都只使用 AOF 持久化， 但我们并不推荐这种方式： 因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比AOF恢复的速度要快，除此之外，使用RDB还可以避免之前提到的AOF程序的bug。 3. 总结 本文主要讲解了Redis事务运用实例，以及数据持久化的方式，各自优缺点和如何选择合适的方式等知识.","categories":[{"name":"数据库","slug":"数据库","permalink":"http://smartfice.com/categories/数据库/"}],"tags":[{"name":"nosql","slug":"nosql","permalink":"http://smartfice.com/tags/nosql/"},{"name":"Redis","slug":"Redis","permalink":"http://smartfice.com/tags/Redis/"}]}]}