{"meta":{"title":"Monkey'blog","subtitle":"welcome to monkey","description":"smartfice python","author":"smartfice","url":"http://smartfice.com"},"pages":[{"title":"about","date":"2017-09-30T06:51:06.000Z","updated":"2017-09-30T06:51:06.629Z","comments":true,"path":"about/index.html","permalink":"http://smartfice.com/about/index.html","excerpt":"","text":""},{"title":"images","date":"2017-10-05T13:58:38.000Z","updated":"2017-10-05T13:58:38.059Z","comments":true,"path":"images/index.html","permalink":"http://smartfice.com/images/index.html","excerpt":"","text":""},{"title":"All categories","date":"2017-10-08T07:46:45.000Z","updated":"2017-10-08T07:47:46.286Z","comments":true,"path":"categories/index.html","permalink":"http://smartfice.com/categories/index.html","excerpt":"","text":""},{"title":"All tags","date":"2017-10-08T07:44:15.000Z","updated":"2017-10-08T07:45:36.118Z","comments":true,"path":"tags/index.html","permalink":"http://smartfice.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Django middleware","slug":"middleware","date":"2017-09-29T09:00:41.666Z","updated":"2017-09-29T09:00:41.662Z","comments":true,"path":"middleware/","link":"","permalink":"http://smartfice.com/middleware/","excerpt":"","text":"Django中间件是一个轻量级、底层的插件系统，可以介入Django的请求和响应处理过程，修改Django的输入或输出。中间件为设计开发者提供了一种无侵入式的开发方式。在middleware.py文件中定义中间件类： init(self) :服务器响应第一个请求的时候调用。 process_request(self, request)(每个请求上调用,返回None或者HttpResponse对象)：是产生request对象,进行url匹配之前调用 process_view(self, request, view_func, view_args, *view_kwargs)（每个请求上调用,返回None或者HttpResponse对象 ）:是url匹配之后,调用视图函数之前. process_response(self, request, response)（每个请求上调用,返回HttpResponse对象 ）:视图函数调用之后，内容返回给浏览器之前。 process_exception(self, request, exception)（每个请求上调用,返回HttpResponse对象 ）:视图函数出现异常，会调用这个函数如果多个中间件类包含process_exception函数的时候，调用的顺序跟注册的顺序是相反的 注册中间件类：settings.py MIDDLEWARE_CLASSES = [ ]比如我们要做一个 拦截器，发生有恶意访问网站的人，就拦截他！Django中间件实现拦截器 JavaWeb Struts2的拦截器我们都能很熟悉，在请求交给Action处理之前，先在拦截器中处理，处理完之后再交给Action。在Django中如何实现相同的效果? 在process_request方法中，返回值为HttpResponse类型的对象的时候不交给普通的控制器处理，直接返回给浏览器，返回值为None的时候，请求处理完之后交给普通的控制器处理。 使用request对象的META属性：request.META[‘REMOTE_ADDR’] 获取访问者的ip 假如我们通过一种技术，比如统计一分钟访问页面数，太多就把他的 IP 加入到黑名单 BLOCKED_IPS（这部分没有提供代码，主要讲中间件部分）项目 文件名 zscf 1234class BlockedIpMiddleware(object): def process_request(self, request): if request.META['REMOTE_ADDR'] in getattr(settings, \"BLOCKED_IPS\", []): return http.HttpResponseForbidden('&lt;h1&gt;Forbidden&lt;/h1&gt;') 这里的代码的功能就是 获取当前访问者的 IP (request.META[‘REMOTE_ADDR’])，如果这个 IP 在黑名单中就拦截，如果不在就返回 None (函数中没有返回值其实就是默认为 None)，把这个中间件的 Python 路径写到settings.py中 1234MIDDLEWARE_CLASSES = ( 'zscf.middleware.BlockedIpMiddleware', ...其它的中间件) Django 会从 MIDDLEWARE_CLASSES 中按照从上到下的顺序一个个执行中间件中的 process_request 函数，而其中 process_response 函数则是最前面的最后执行。 再比如，我们在网站放到服务器上正式运行后，DEBUG改为了 False，这样更安全，但是有时候发生错误不能显示错误详情页面，有没有办法处理好这两个事情呢？ 普通访问者看到的是友好的报错信息 管理员看到的是错误详情，以便于修复 BUG 当然可以有，利用中间件就可以做到！代码如下：12345678import sysfrom django.views.debug import technical_500_responsefrom django.conf import settings class UserBasedExceptionMiddleware(object): def process_exception(self, request, exception): if request.user.is_superuser or request.META.get('REMOTE_ADDR') in settings.INTERNAL_IPS: return technical_500_response(request, *sys.exc_info()) 把这个中间件像上面一样，加到你的 settings.py 中的 MIDDLEWARE_CLASSES 中，可以放到最后，这样可以看到其它中间件的 process_request的错误。","categories":[],"tags":[]},{"title":"python","slug":"python","date":"2017-09-28T12:29:10.000Z","updated":"2017-09-28T12:38:19.249Z","comments":true,"path":"python/","link":"","permalink":"http://smartfice.com/python/","excerpt":"","text":"欢迎来到我的技术","categories":[],"tags":[]}]}